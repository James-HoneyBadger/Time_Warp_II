#!/usr/bin/env python3
"""
TempleCode IDE - Single-Language Programming Environment

A single-language IDE for the TempleCode programming language,
a fusion of BASIC, PILOT, and Logo with integrated turtle graphics.

Copyright ¬© 2025 Honey Badger Universe. All rights reserved.

Supports: TempleCode (a fusion of BASIC, PILOT, and Logo)

Features:
- TempleCode language with built-in examples
- Integrated turtle graphics for visual programming
- Multiple color themes and font sizes
- File persistence for editor content
- Educational feedback and error messages
"""
# pylint: disable=C0301,C0103,R1705,W0621,W0718,W0404,C0415,W1510

import sys
import json
from pathlib import Path


def main():
    """Main entry point - launches TempleCode IDE."""

    # Launch GUI
    print("üöÄ Launching TempleCode IDE...")
    try:
        # Import and launch the GUI application
        import tkinter as tk
        from tkinter import scrolledtext, messagebox, filedialog
        from core.interpreter import TempleCodeInterpreter
        from core.features.syntax_highlighting import SyntaxHighlightingText, LineNumberedText

        # Import GUI optimizer
        try:
            from core.optimizations.gui_optimizer import initialize_gui_optimizer
            GUI_OPTIMIZATIONS_AVAILABLE = True
        except ImportError:
            GUI_OPTIMIZATIONS_AVAILABLE = False
            initialize_gui_optimizer = None

        # Check if pygments is available for syntax highlighting
        try:
            import pygments  # noqa: F401
            PYGMENTS_AVAILABLE = True
        except ImportError:
            PYGMENTS_AVAILABLE = False

        # Settings file for persistence
        SETTINGS_FILE = Path.home() / ".templecode_settings.json"

        def load_settings():
            """Load user settings from file."""
            try:
                if SETTINGS_FILE.exists():
                    with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                        return json.load(f)
            except Exception:
                pass
            return {"theme": "dark", "font_size": "medium", "font_family": "Courier"}

        def save_settings(theme, font_size, font_family):
            """Save user settings to file."""
            try:
                with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                    json.dump({"theme": theme, "font_size": font_size, "font_family": font_family}, f)
            except Exception:
                pass

        # Load saved settings
        settings = load_settings()
        current_theme = settings.get("theme", "dark")
        current_font = settings.get("font_size", "medium")
        current_font_family = settings.get("font_family", "Courier")

        # Create the main GUI window
        root = tk.Tk()
        root.title("TempleCode IDE")
        root.geometry("1200x800")
        root.config(bg="#252526")

        # Initialize GUI optimizer for performance improvements
        if GUI_OPTIMIZATIONS_AVAILABLE and initialize_gui_optimizer:
            gui_optimizer = initialize_gui_optimizer(root)
            print("üöÄ GUI optimizations enabled")
        else:
            gui_optimizer = None
            print("‚ÑπÔ∏è  GUI optimizations not available")

        # Create menu bar
        menubar = tk.Menu(root)
        root.config(menu=menubar, bg="#252526")

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)

        # Editor text widget (declare early for menu functions)
        editor_text = None
        output_text = None
        interpreter = None

        def load_file():
            """Load a file into the editor."""
            filename = filedialog.askopenfilename(
                title="Open Program File",
                filetypes=[
                    ("TempleCode Files", "*.tc"),
                    ("All Files", "*.*"),
                ],
            )
            if filename:
                try:
                    with open(filename, "r", encoding="utf-8") as f:
                        content = f.read()
                    editor_text.delete("1.0", tk.END)
                    editor_text.insert("1.0", content)
                    output_text.insert(tk.END, f"üìÇ Loaded: {filename}\n")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to load file:\n{e}")

        def save_file():
            """Save the editor content to a file."""
            filename = filedialog.asksaveasfilename(
                title="Save Program File",
                defaultextension=".tc",
                filetypes=[
                    ("TempleCode Files", "*.tc"),
                    ("All Files", "*.*"),
                ],
            )
            if filename:
                try:
                    content = editor_text.get("1.0", tk.END)
                    with open(filename, "w", encoding="utf-8") as f:
                        f.write(content)
                    output_text.insert(tk.END, f"üíæ Saved: {filename}\n")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to save file:\n{e}")

        def new_file():
            """Create a new file."""
            if messagebox.askyesno("New File", "Clear current editor content?"):
                editor_text.delete("1.0", tk.END)
                output_text.insert(tk.END, "üìÑ New file created\n")

        def exit_app():
            """Exit the application."""
            if messagebox.askyesno("Exit", "Are you sure you want to exit?"):
                root.destroy()

        file_menu.add_command(label="New File", command=new_file, accelerator="Ctrl+N")
        file_menu.add_command(
            label="Open File...", command=load_file, accelerator="Ctrl+O"
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Save File...", command=save_file, accelerator="Ctrl+S"
        )
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=exit_app, accelerator="Ctrl+Q")

        # Edit menu
        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=edit_menu)

        def cut_text():
            """Cut selected text to clipboard."""
            try:
                editor_text.event_generate("<<Cut>>")
            except Exception:
                pass

        def copy_text():
            """Copy selected text to clipboard."""
            try:
                editor_text.event_generate("<<Copy>>")
            except Exception:
                pass

        def paste_text():
            """Paste text from clipboard."""
            try:
                editor_text.event_generate("<<Paste>>")
            except Exception:
                pass

        def undo_text():
            """Undo last edit."""
            try:
                editor_text.edit_undo()
            except Exception:
                pass

        def redo_text():
            """Redo last undone edit."""
            try:
                editor_text.edit_redo()
            except Exception:
                pass

        def select_all():
            """Select all text in editor."""
            editor_text.tag_add("sel", "1.0", tk.END)
            editor_text.mark_set("insert", "1.0")
            editor_text.see("insert")
            return "break"

        def clear_editor():
            """Clear the editor."""
            editor_text.delete("1.0", tk.END)

        def clear_output():
            """Clear the output window."""
            output_text.delete("1.0", tk.END)

        def clear_canvas():
            """Clear the turtle graphics canvas and reset turtle state."""
            turtle_canvas.delete("all")
            if hasattr(interpreter, 'turtle_graphics') and interpreter.turtle_graphics:
                interpreter.turtle_graphics["x"] = 0.0
                interpreter.turtle_graphics["y"] = 0.0
                interpreter.turtle_graphics["heading"] = 0.0
                interpreter.turtle_graphics["lines"] = []
                interpreter.update_turtle_display()
            output_text.insert(tk.END, "üé® Canvas cleared\n")

        edit_menu.add_command(label="Undo", command=undo_text, accelerator="Ctrl+Z")
        edit_menu.add_command(label="Redo", command=redo_text, accelerator="Ctrl+Y")
        edit_menu.add_separator()
        edit_menu.add_command(label="Cut", command=cut_text, accelerator="Ctrl+X")
        edit_menu.add_command(label="Copy", command=copy_text, accelerator="Ctrl+C")
        edit_menu.add_command(label="Paste", command=paste_text, accelerator="Ctrl+V")
        edit_menu.add_separator()
        edit_menu.add_command(label="Select All", command=select_all, accelerator="Ctrl+A")
        edit_menu.add_separator()
        edit_menu.add_command(label="Clear Editor", command=clear_editor)
        edit_menu.add_command(label="Clear Output", command=clear_output)
        edit_menu.add_command(label="Clear Graphics", command=clear_canvas)
        edit_menu.add_separator()

        def find_text():
            """Open find dialog."""
            find_dialog = tk.Toplevel(root)
            find_dialog.title("Find")
            find_dialog.geometry("400x150")
            find_dialog.resizable(False, False)
            
            # Center the dialog
            find_dialog.transient(root)
            find_dialog.grab_set()
            
            # Search term
            tk.Label(find_dialog, text="Find:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
            search_var = tk.StringVar()
            search_entry = tk.Entry(find_dialog, textvariable=search_var, width=30)
            search_entry.grid(row=0, column=1, padx=5, pady=5)
            search_entry.focus()
            
            # Options
            options_frame = tk.Frame(find_dialog)
            options_frame.grid(row=1, column=0, columnspan=2, pady=5)
            
            case_var = tk.BooleanVar()
            whole_var = tk.BooleanVar()
            regex_var = tk.BooleanVar()
            
            tk.Checkbutton(options_frame, text="Case sensitive", variable=case_var).pack(side=tk.LEFT, padx=5)
            tk.Checkbutton(options_frame, text="Whole word", variable=whole_var).pack(side=tk.LEFT, padx=5)
            tk.Checkbutton(options_frame, text="Regex", variable=regex_var).pack(side=tk.LEFT, padx=5)
            
            # Buttons
            button_frame = tk.Frame(find_dialog)
            button_frame.grid(row=2, column=0, columnspan=2, pady=10)
            
            def do_find():
                search_term = search_var.get()
                if search_term:
                    editor_text.clear_search_highlights()
                    match = editor_text.find_text(
                        search_term,
                        start_pos=editor_text.index(tk.INSERT),
                        case_sensitive=case_var.get(),
                        whole_word=whole_var.get(),
                        regex=regex_var.get()
                    )
                    if match:
                        start_idx, end_idx = match
                        editor_text.tag_remove("sel", "1.0", tk.END)
                        editor_text.tag_add("sel", start_idx, end_idx)
                        editor_text.mark_set(tk.INSERT, end_idx)
                        editor_text.see(start_idx)
                        editor_text.highlight_search_results(
                            search_term,
                            case_sensitive=case_var.get(),
                            whole_word=whole_var.get(),
                            regex=regex_var.get()
                        )
                        output_text.insert(tk.END, f"Found '{search_term}' at {start_idx}\n")
                    else:
                        output_text.insert(tk.END, f"'{search_term}' not found\n")
            
            def find_next():
                do_find()
            
            tk.Button(button_frame, text="Find", command=do_find, width=10).pack(side=tk.LEFT, padx=5)
            tk.Button(button_frame, text="Find Next", command=find_next, width=10).pack(side=tk.LEFT, padx=5)
            tk.Button(button_frame, text="Close", command=find_dialog.destroy, width=10).pack(side=tk.LEFT, padx=5)
            
            # Bind Enter key
            search_entry.bind('<Return>', lambda e: do_find())
            
            # Bind Escape to close
            find_dialog.bind('<Escape>', lambda e: find_dialog.destroy())

        def replace_text():
            """Open replace dialog."""
            replace_dialog = tk.Toplevel(root)
            replace_dialog.title("Replace")
            replace_dialog.geometry("400x180")
            replace_dialog.resizable(False, False)
            
            # Center the dialog
            replace_dialog.transient(root)
            replace_dialog.grab_set()
            
            # Search term
            tk.Label(replace_dialog, text="Find:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
            search_var = tk.StringVar()
            search_entry = tk.Entry(replace_dialog, textvariable=search_var, width=30)
            search_entry.grid(row=0, column=1, padx=5, pady=5)
            
            # Replace term
            tk.Label(replace_dialog, text="Replace:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
            replace_var = tk.StringVar()
            replace_entry = tk.Entry(replace_dialog, textvariable=replace_var, width=30)
            replace_entry.grid(row=1, column=1, padx=5, pady=5)
            
            # Options
            options_frame = tk.Frame(replace_dialog)
            options_frame.grid(row=2, column=0, columnspan=2, pady=5)
            
            case_var = tk.BooleanVar()
            whole_var = tk.BooleanVar()
            regex_var = tk.BooleanVar()
            
            tk.Checkbutton(options_frame, text="Case sensitive", variable=case_var).pack(side=tk.LEFT, padx=5)
            tk.Checkbutton(options_frame, text="Whole word", variable=whole_var).pack(side=tk.LEFT, padx=5)
            tk.Checkbutton(options_frame, text="Regex", variable=regex_var).pack(side=tk.LEFT, padx=5)
            
            # Buttons
            button_frame = tk.Frame(replace_dialog)
            button_frame.grid(row=3, column=0, columnspan=2, pady=10)
            
            def do_replace():
                search_term = search_var.get()
                replace_term = replace_var.get()
                if search_term:
                    replaced = editor_text.replace_text(
                        search_term, replace_term,
                        start_pos=editor_text.index(tk.INSERT),
                        case_sensitive=case_var.get(),
                        whole_word=whole_var.get(),
                        regex=regex_var.get()
                    )
                    if replaced:
                        output_text.insert(tk.END, f"Replaced '{search_term}' with '{replace_term}'\n")
                        # Re-highlight search results
                        editor_text.highlight_search_results(
                            search_term,
                            case_sensitive=case_var.get(),
                            whole_word=whole_var.get(),
                            regex=regex_var.get()
                        )
                    else:
                        output_text.insert(tk.END, f"'{search_term}' not found\n")
            
            def replace_all():
                search_term = search_var.get()
                replace_term = replace_var.get()
                if search_term:
                    count = editor_text.replace_all(
                        search_term, replace_term,
                        case_sensitive=case_var.get(),
                        whole_word=whole_var.get(),
                        regex=regex_var.get()
                    )
                    output_text.insert(tk.END, f"Replaced {count} occurrence(s) of '{search_term}' with '{replace_term}'\n")
                    editor_text.clear_search_highlights()
            
            tk.Button(button_frame, text="Replace", command=do_replace, width=10).pack(side=tk.LEFT, padx=5)
            tk.Button(button_frame, text="Replace All", command=replace_all, width=10).pack(side=tk.LEFT, padx=5)
            tk.Button(button_frame, text="Close", command=replace_dialog.destroy, width=10).pack(side=tk.LEFT, padx=5)
            
            # Focus on search entry
            search_entry.focus()
            
            # Bind Escape to close
            replace_dialog.bind('<Escape>', lambda e: replace_dialog.destroy())

        edit_menu.add_command(label="Find...", command=find_text, accelerator="Ctrl+F")
        edit_menu.add_command(label="Replace...", command=replace_text, accelerator="Ctrl+H")

        def run_code():
            """Execute the code in the editor."""
            code = editor_text.get("1.0", tk.END)
            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, "üöÄ Running program...\n\n")
            try:
                # Keep turtle canvas wired before execution
                interpreter.ide_turtle_canvas = turtle_canvas

                # Reset turtle state and canvas before each run
                if turtle_canvas is not None:
                    turtle_canvas.delete("all")
                interpreter.turtle_graphics = None
                interpreter.init_turtle_graphics()
                interpreter.clear_turtle_screen()

                interpreter.run_program(code, language="templecode")
                output_text.insert(tk.END, "\n‚úÖ Program completed.\n")
            except Exception as e:
                output_text.insert(tk.END, f"\n‚ùå Error: {e}\n")

        # Program menu
        program_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Program", menu=program_menu)

        program_menu.add_command(label="Run Program", command=run_code, accelerator="F5")
        program_menu.add_separator()

        # Examples submenu under Program
        examples_menu = tk.Menu(program_menu, tearoff=0)
        program_menu.add_cascade(label="Load Example", menu=examples_menu)

        def load_example(filepath):
            """Load an example program."""
            try:
                with open(filepath, "r", encoding="utf-8") as f:
                    content = f.read()
                editor_text.delete("1.0", tk.END)
                editor_text.insert("1.0", content)
                output_text.insert(tk.END, f"üìö Loaded example: {filepath}\n")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load example:\n{e}")

        # TempleCode examples
        examples_menu.add_command(
            label="Hello World",
            command=lambda: load_example("examples/templecode/hello.tc"),
        )
        examples_menu.add_command(
            label="Turtle Graphics Spiral",
            command=lambda: load_example("examples/templecode/spiral.tc"),
        )
        examples_menu.add_command(
            label="Quiz (PILOT style)",
            command=lambda: load_example("examples/templecode/quiz.tc"),
        )
        examples_menu.add_command(
            label="Number Guessing Game",
            command=lambda: load_example("examples/templecode/guess.tc"),
        )
        examples_menu.add_command(
            label="Mandelbrot (Turtle Art)",
            command=lambda: load_example("examples/templecode/mandelbrot.tc"),
        )

        def show_error_history():
            """Show the error history in a dialog."""
            if not hasattr(interpreter, 'error_history') or not interpreter.error_history:
                messagebox.showinfo("Error History", "No errors recorded.")
                return
            
            history_text = "Recent Errors:\n\n"
            for i, error in enumerate(interpreter.error_history[-10:], 1):  # Show last 10 errors
                history_text += f"{i}. Line {error.get('line', 'N/A')}: {error['message']}\n"
            
            # Create a scrollable dialog for error history
            history_window = tk.Toplevel(root)
            history_window.title("Error History")
            history_window.geometry("600x400")
            
            text_widget = scrolledtext.ScrolledText(history_window, wrap=tk.WORD)
            text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            text_widget.insert(tk.END, history_text)
            text_widget.config(state=tk.DISABLED)

        # Debug menu
        debug_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Debug", menu=debug_menu)

        # Debug mode toggle
        debug_enabled = tk.BooleanVar(value=False)
        debug_menu.add_checkbutton(label="Enable Debug Mode", variable=debug_enabled,
                                   command=lambda: interpreter.set_debug_mode(debug_enabled.get()))
        debug_menu.add_separator()

        # Breakpoint management
        debug_menu.add_command(label="Clear All Breakpoints",
                               command=lambda: interpreter.breakpoints.clear())
        debug_menu.add_separator()

        # Error history
        debug_menu.add_command(label="Show Error History", command=show_error_history)
        debug_menu.add_command(label="Clear Error History",
                               command=lambda: setattr(interpreter, 'error_history', []))

        # Test menu
        test_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Test", menu=test_menu)

        def run_smoke_test():
            """Run a quick smoke test."""
            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, "üß™ Running smoke test...\n")

            try:
                # Test basic interpreter functionality
                test_result = interpreter.evaluate_expression("2 + 3")
                if test_result == 5:
                    output_text.insert(tk.END, "‚úÖ Basic evaluation: PASS\n")
                else:
                    output_text.insert(tk.END, f"‚ùå Basic evaluation: FAIL (got {test_result})\n")

                # Test variable assignment
                interpreter.variables['TEST_VAR'] = 42
                if interpreter.variables.get('TEST_VAR') == 42:
                    output_text.insert(tk.END, "‚úÖ Variable assignment: PASS\n")
                else:
                    output_text.insert(tk.END, "‚ùå Variable assignment: FAIL\n")

                # Test program loading
                test_program = 'PRINT "Test passed!"'
                if interpreter.load_program(test_program):
                    output_text.insert(tk.END, "‚úÖ Program loading: PASS\n")
                else:
                    output_text.insert(tk.END, "‚ùå Program loading: FAIL\n")

                output_text.insert(tk.END, "\nüéâ Smoke test completed!\n")

            except Exception as e:
                output_text.insert(tk.END, f"\n‚ùå Smoke test failed: {e}\n")

        def run_full_test_suite():
            """Run the full test suite."""
            import subprocess
            import sys

            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, "üß™ Running full test suite...\n")

            try:
                # Run tests using the test script
                result = subprocess.run(
                    [sys.executable, "scripts/run_tests.py", "all", "-v"],
                    capture_output=True,
                    text=True,
                    cwd="."
                )

                output_text.insert(tk.END, result.stdout)
                if result.stderr:
                    output_text.insert(tk.END, "\nErrors:\n" + result.stderr)

                if result.returncode == 0:
                    output_text.insert(tk.END, "\n‚úÖ All tests passed!\n")
                else:
                    output_text.insert(tk.END, f"\n‚ùå Tests failed with code {result.returncode}\n")

            except Exception as e:
                output_text.insert(tk.END, f"\n‚ùå Failed to run tests: {e}\n")

        test_menu.add_command(label="Run Smoke Test", command=run_smoke_test)
        test_menu.add_command(label="Run Full Test Suite", command=run_full_test_suite)
        test_menu.add_separator()
        test_menu.add_command(label="Open Examples Directory",
                              command=lambda: __import__('subprocess').run(["xdg-open", "examples"]))

        # Performance menu
        performance_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Performance", menu=performance_menu)

        def show_performance_stats():
            """Show performance statistics."""
            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, "üìä Performance Statistics\n")
            output_text.insert(tk.END, "=" * 50 + "\n\n")

            try:
                # Interpreter performance stats
                if hasattr(interpreter, 'get_performance_stats'):
                    interp_stats = interpreter.get_performance_stats()
                    output_text.insert(tk.END, "Interpreter Performance:\n")
                    output_text.insert(tk.END, f"  Expression Cache: {interp_stats.get('expression_cache', {}).get('hit_rate', 0):.2%} hit rate\n")
                    output_text.insert(tk.END, f"  Profiling: {interp_stats.get('profiler', {})}\n")
                    output_text.insert(tk.END, f"  Memory: {interp_stats.get('memory', {}).get('gc_objects', 0)} objects\n")
                    output_text.insert(tk.END, f"  Lazy Modules: {len(interp_stats.get('lazy_loaded_modules', []))} loaded\n\n")

                # GUI performance stats
                if gui_optimizer:
                    gui_stats = gui_optimizer.get_performance_stats()
                    output_text.insert(tk.END, "GUI Performance:\n")
                    output_text.insert(tk.END, f"  Updates/sec: {gui_stats.get('updates_per_second', 0):.1f}\n")
                    output_text.insert(tk.END, f"  Async Text Widgets: {gui_stats.get('async_text_widgets', 0)}\n")
                    output_text.insert(tk.END, f"  Optimized Canvases: {gui_stats.get('optimized_canvases', 0)}\n")
                    output_text.insert(tk.END, f"  Pending Tasks: {gui_stats.get('pending_ui_tasks', 0)}\n\n")

                # Memory usage
                try:
                    import psutil
                    import os
                    process = psutil.Process(os.getpid())
                    memory_info = process.memory_info()
                    output_text.insert(tk.END, "Memory Usage:\n")
                    output_text.insert(tk.END, f"  RSS: {memory_info.rss / 1024 / 1024:.1f} MB\n")
                    output_text.insert(tk.END, f"  VMS: {memory_info.vms / 1024 / 1024:.1f} MB\n")
                    output_text.insert(tk.END, f"  GC Objects: {__import__('gc').get_count()[0]}\n\n")
                except ImportError:
                    output_text.insert(tk.END, "Memory Usage: psutil not available\n\n")

                output_text.insert(tk.END, "üí° Performance Tips:\n")
                output_text.insert(tk.END, "  ‚Ä¢ Expression caching reduces evaluation time\n")
                output_text.insert(tk.END, "  ‚Ä¢ Lazy loading improves startup time\n")
                output_text.insert(tk.END, "  ‚Ä¢ GUI optimizations reduce UI lag\n")
                output_text.insert(tk.END, "  ‚Ä¢ Memory pools reduce allocation overhead\n")

            except Exception as e:
                output_text.insert(tk.END, f"‚ùå Error getting performance stats: {e}\n")

        def optimize_performance():
            """Apply performance optimizations."""
            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, "‚ö° Applying Performance Optimizations...\n\n")

            try:
                # Interpreter optimizations
                if hasattr(interpreter, 'optimize_for_production'):
                    interp_result = interpreter.optimize_for_production()
                    output_text.insert(tk.END, "Interpreter Optimizations:\n")
                    output_text.insert(tk.END, f"  Cache cleared: {interp_result.get('cache_cleared', False)}\n")
                    output_text.insert(tk.END, f"  Objects collected: {interp_result.get('objects_collected', 0)}\n")
                    output_text.insert(tk.END, f"  Variables optimized: {interp_result.get('variables_optimized', False)}\n\n")

                # GUI optimizations
                if gui_optimizer and hasattr(gui_optimizer, 'optimize_for_performance'):
                    gui_result = gui_optimizer.optimize_for_performance()
                    output_text.insert(tk.END, "GUI Optimizations:\n")
                    output_text.insert(tk.END, f"  Canvases flushed: {gui_result.get('canvases_flushed', 0)}\n")
                    output_text.insert(tk.END, f"  Text widgets synced: {gui_result.get('text_widgets_synced', 0)}\n")
                    output_text.insert(tk.END, f"  Tasks remaining: {gui_result.get('ui_tasks_remaining', 0)}\n\n")

                # Global optimizations
                try:
                    from core.optimizations import cleanup_all_resources
                    cleanup_result = cleanup_all_resources()
                    output_text.insert(tk.END, "Global Cleanup:\n")
                    output_text.insert(tk.END, f"  Cache cleared: {cleanup_result.get('cache_cleared', False)}\n")
                    output_text.insert(tk.END, f"  Dead references cleaned: {cleanup_result.get('dead_references_cleaned', 0)}\n")
                    output_text.insert(tk.END, f"  Garbage collected: {cleanup_result.get('garbage_collected', 0)}\n")
                    output_text.insert(tk.END, f"  Callbacks executed: {cleanup_result.get('callbacks_executed', 0)}\n\n")
                except ImportError:
                    output_text.insert(tk.END, "Global cleanup: optimizations not available\n\n")

                output_text.insert(tk.END, "‚úÖ Performance optimizations applied!\n")

            except Exception as e:
                output_text.insert(tk.END, f"‚ùå Error applying optimizations: {e}\n")

        def toggle_profiling():
            """Toggle performance profiling."""
            if hasattr(interpreter, 'enable_profiling'):
                interpreter.enable_profiling = not interpreter.enable_profiling
                state = "enabled" if interpreter.enable_profiling else "disabled"
                output_text.insert(tk.END, f"üîç Performance profiling {state}\n")
            else:
                output_text.insert(tk.END, "‚ÑπÔ∏è  Profiling not available\n")

        performance_menu.add_command(label="Show Statistics", command=show_performance_stats)
        performance_menu.add_command(label="Optimize Performance", command=optimize_performance)
        performance_menu.add_command(label="Toggle Profiling", command=toggle_profiling)
        performance_menu.add_separator()
performance_menu.add_command(
            label="Open Optimizations",
            command=lambda: __import__('subprocess').run(["xdg-open", "core/optimizations"]))

        # Preferences menu
        preferences_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Preferences", menu=preferences_menu)

        # Theme submenu
        theme_menu = tk.Menu(preferences_menu, tearoff=0)
        preferences_menu.add_cascade(label="Color Theme", menu=theme_menu)

        # Define theme configurations
        THEMES = {
            "light": {
                "name": "Light",
                "text_bg": "white", "text_fg": "black",
                "canvas_bg": "white", "canvas_border": "#cccccc",
                "root_bg": "#f0f0f0", "frame_bg": "#f0f0f0",
                "editor_frame_bg": "white", "editor_frame_fg": "black",
                "input_bg": "white", "input_fg": "black"
            },
            "dark": {
                "name": "Dark",
                "text_bg": "#1e1e1e", "text_fg": "#d4d4d4",
                "canvas_bg": "#2d2d2d", "canvas_border": "#3e3e3e",
                "root_bg": "#252526", "frame_bg": "#252526",
                "editor_frame_bg": "#252526", "editor_frame_fg": "#d4d4d4",
                "input_bg": "#1e1e1e", "input_fg": "#d4d4d4"
            },
            "classic": {
                "name": "Classic",
                "text_bg": "white", "text_fg": "black",
                "canvas_bg": "#fffef0", "canvas_border": "#cccccc",
                "root_bg": "#e0e0e0", "frame_bg": "#e0e0e0",
                "editor_frame_bg": "#e0e0e0", "editor_frame_fg": "black",
                "input_bg": "white", "input_fg": "black"
            },
            "solarized_dark": {
                "name": "Solarized Dark",
                "text_bg": "#002b36", "text_fg": "#839496",
                "canvas_bg": "#073642", "canvas_border": "#586e75",
                "root_bg": "#002b36", "frame_bg": "#002b36",
                "editor_frame_bg": "#002b36", "editor_frame_fg": "#839496",
                "input_bg": "#073642", "input_fg": "#839496"
            },
            "solarized_light": {
                "name": "Solarized Light",
                "text_bg": "#fdf6e3", "text_fg": "#657b83",
                "canvas_bg": "#eee8d5", "canvas_border": "#93a1a1",
                "root_bg": "#fdf6e3", "frame_bg": "#fdf6e3",
                "editor_frame_bg": "#fdf6e3", "editor_frame_fg": "#657b83",
                "input_bg": "#eee8d5", "input_fg": "#657b83"
            },
            "monokai": {
                "name": "Monokai",
                "text_bg": "#272822", "text_fg": "#f8f8f2",
                "canvas_bg": "#3e3d32", "canvas_border": "#75715e",
                "root_bg": "#272822", "frame_bg": "#272822",
                "editor_frame_bg": "#272822", "editor_frame_fg": "#f8f8f2",
                "input_bg": "#3e3d32", "input_fg": "#f8f8f2"
            },
            "dracula": {
                "name": "Dracula",
                "text_bg": "#282a36", "text_fg": "#f8f8f2",
                "canvas_bg": "#44475a", "canvas_border": "#6272a4",
                "root_bg": "#282a36", "frame_bg": "#282a36",
                "editor_frame_bg": "#282a36", "editor_frame_fg": "#f8f8f2",
                "input_bg": "#44475a", "input_fg": "#f8f8f2"
            },
            "nord": {
                "name": "Nord",
                "text_bg": "#2e3440", "text_fg": "#d8dee9",
                "canvas_bg": "#3b4252", "canvas_border": "#4c566a",
                "root_bg": "#2e3440", "frame_bg": "#2e3440",
                "editor_frame_bg": "#2e3440", "editor_frame_fg": "#d8dee9",
                "input_bg": "#3b4252", "input_fg": "#d8dee9"
            },
            "high_contrast": {
                "name": "High Contrast",
                "text_bg": "black", "text_fg": "white",
                "canvas_bg": "#0a0a0a", "canvas_border": "white",
                "root_bg": "black", "frame_bg": "black",
                "editor_frame_bg": "black", "editor_frame_fg": "white",
                "input_bg": "#0a0a0a", "input_fg": "white"
            }
        }

        def apply_theme(theme_key):
            """Apply a theme to all UI elements."""
            nonlocal current_theme
            theme = THEMES[theme_key]
            
            # Text widgets - handle both regular text and syntax highlighting widgets
            if hasattr(editor_text, 'text'):
                # Syntax highlighting widget
                editor_text.text.config(bg=theme["text_bg"], fg=theme["text_fg"],
                                        insertbackground=theme["text_fg"])
                # Update syntax highlighting theme
                if hasattr(editor_text, 'set_theme'):
                    editor_text.set_theme(theme_key)
                
                # Update line numbers background
                if hasattr(editor_text, 'line_numbers'):
                    bg_color = {'dark': '#1e1e1e', 'light': '#f0f0f0', 'monokai': '#272822',
                                'classic': '#ffffff', 'solarized_dark': '#002b36', 'solarized_light': '#fdf6e3',
                                'dracula': '#282a36', 'nord': '#2e3440', 'high_contrast': '#000000'}.get(theme_key, '#1e1e1e')
                    editor_text.line_numbers.config(bg=bg_color)
            else:
                # Regular text widget
                editor_text.config(bg=theme["text_bg"], fg=theme["text_fg"],
                                   insertbackground=theme["text_fg"])
            
            output_text.config(bg=theme["text_bg"], fg=theme["text_fg"],
                               insertbackground=theme["text_fg"])
            
            # Canvas
            turtle_canvas.config(bg=theme["canvas_bg"],
                                 highlightbackground=theme["canvas_border"])
            
            # Frames
            root.config(bg=theme["root_bg"])
            left_panel.config(bg=theme["frame_bg"])
            right_panel.config(bg=theme["frame_bg"])
            editor_frame.config(bg=theme["editor_frame_bg"], fg=theme["editor_frame_fg"])
            output_frame.config(bg=theme["editor_frame_bg"], fg=theme["editor_frame_fg"])
            graphics_frame.config(bg=theme["editor_frame_bg"], fg=theme["editor_frame_fg"])
            input_frame.config(bg=theme["frame_bg"])
            button_frame.config(bg=theme["frame_bg"])
            
            # Input widget
            input_entry.config(bg=theme["input_bg"], fg=theme["input_fg"],
                               insertbackground=theme["input_fg"])
            
            # Update labels
            for widget in input_frame.winfo_children():
                if isinstance(widget, tk.Label):
                    widget.config(bg=theme["frame_bg"], fg=theme["text_fg"])

            # Theme buttons
            for frame in (button_frame, input_frame):
                for widget in frame.winfo_children():
                    if isinstance(widget, tk.Button):
                        widget.config(bg=theme.get("input_bg", "#3e3e3e"),
                                      fg=theme.get("input_fg", "#d4d4d4"))

            # Theme paned windows
            for pw in (main_paned, right_paned):
                try:
                    pw.config(bg=theme["frame_bg"])
                except Exception:
                    pass
            
            # Save setting
            current_theme = theme_key
            save_settings(current_theme, current_font, current_font_family)

        # Add theme menu items
        for theme_key, theme_data in THEMES.items():
            theme_menu.add_command(
                label=theme_data["name"],
                command=lambda k=theme_key: apply_theme(k)
            )

        # Font family submenu
        font_family_menu = tk.Menu(preferences_menu, tearoff=0)
        preferences_menu.add_cascade(label="Font Family", menu=font_family_menu)

        def get_available_fonts():
            """Get list of available monospace fonts on the system."""
            import tkinter.font as tkfont
            
            # Get all available font families
            all_fonts = sorted(set(tkfont.families()))
            
            # Prioritize common monospace fonts
            priority_fonts = [
                "Courier", "Courier New", "Consolas", "Monaco", "Menlo",
                "DejaVu Sans Mono", "Liberation Mono", "Ubuntu Mono",
                "Fira Code", "Source Code Pro", "JetBrains Mono",
                "Cascadia Code", "SF Mono", "Inconsolata", "Roboto Mono",
                "Hack", "Anonymous Pro", "Droid Sans Mono", "PT Mono"
            ]
            
            # Separate priority fonts that exist from the rest
            priority_available = [f for f in priority_fonts if f in all_fonts]
            other_fonts = [f for f in all_fonts if f not in priority_fonts]
            
            # Return priority fonts first, then others
            return priority_available + other_fonts

        def apply_font_family(family_name):
            """Apply a font family to editor and output."""
            nonlocal current_font_family
            size = FONT_SIZES[current_font]
            
            # Apply font to editor text widget
            if hasattr(editor_text, 'set_font'):
                editor_text.set_font((family_name, size["editor"]))
            else:
                editor_text.config(font=(family_name, size["editor"]))
            
            output_text.config(font=(family_name, size["output"]))
            
            # Save setting
            current_font_family = family_name
            save_settings(current_theme, current_font, current_font_family)

        # Get available fonts and create menu items
        available_fonts = get_available_fonts()
        
        # Add first 25 fonts directly to menu
        for i, font_name in enumerate(available_fonts[:25]):
            font_family_menu.add_command(
                label=font_name,
                command=lambda f=font_name: apply_font_family(f)
            )
        
        # If there are more fonts, add "More Fonts..." submenu
        if len(available_fonts) > 25:
            font_family_menu.add_separator()
            more_fonts_menu = tk.Menu(font_family_menu, tearoff=0)
            font_family_menu.add_cascade(label="More Fonts...", menu=more_fonts_menu)
            
            # Add remaining fonts to submenu in batches
            for i, font_name in enumerate(available_fonts[25:]):
                more_fonts_menu.add_command(
                    label=font_name,
                    command=lambda f=font_name: apply_font_family(f)
                )

        # Font size submenu
        font_menu = tk.Menu(preferences_menu, tearoff=0)
        preferences_menu.add_cascade(label="Font Size", menu=font_menu)

        # Define font size configurations
        FONT_SIZES = {
            "tiny": {"name": "Tiny (8pt)", "editor": 8, "output": 8},
            "small": {"name": "Small (10pt)", "editor": 10, "output": 9},
            "medium": {"name": "Medium (12pt)", "editor": 12, "output": 11},
            "large": {"name": "Large (14pt)", "editor": 14, "output": 13},
            "xlarge": {"name": "Extra Large (16pt)", "editor": 16, "output": 15},
            "xxlarge": {"name": "Huge (18pt)", "editor": 18, "output": 17},
            "xxxlarge": {"name": "Giant (22pt)", "editor": 22, "output": 20}
        }

        def apply_font_size(size_key):
            """Apply a font size to editor and output."""
            nonlocal current_font
            size = FONT_SIZES[size_key]
            
            # Apply font to editor text widget
            if hasattr(editor_text, 'set_font'):
                editor_text.set_font((current_font_family, size["editor"]))
            else:
                editor_text.config(font=(current_font_family, size["editor"]))
            
            output_text.config(font=(current_font_family, size["output"]))
            
            # Save setting
            current_font = size_key
            save_settings(current_theme, current_font, current_font_family)

        # Add font menu items
        for size_key, size_data in FONT_SIZES.items():
            font_menu.add_command(
                label=size_data["name"],
                command=lambda k=size_key: apply_font_size(k)
            )

        # About menu
        about_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="About", menu=about_menu)

        def show_about():
            """Show about dialog with one top/bottom separator safely sized."""
            # Use a very short ASCII separator to avoid any wrapping
            sep = "-" * 32

            about_text = (
                f"{sep}\n"
                "TempleCode IDE\n"
                "Version 1.0.0\n\n"
                "A single-language IDE for TempleCode,\n"
                "a fusion of BASIC, PILOT, and Logo\n"
                "inspired by the early 1990s.\n\n"
                "FEATURES:\n"
                "  ‚Ä¢ BASIC commands (PRINT, LET, IF, FOR, GOTO)\n"
                "  ‚Ä¢ PILOT commands (T:, A:, M:, Y:, N:, J:)\n"
                "  ‚Ä¢ Logo turtle graphics (FORWARD, RIGHT, REPEAT)\n"
                "  ‚Ä¢ Built-in example programs\n"
                "  ‚Ä¢ Turtle graphics canvas\n"
                "  ‚Ä¢ Multiple color themes\n"
                "  ‚Ä¢ Customizable fonts\n"
                "  ‚Ä¢ Persistent settings\n\n"
                f"{sep}\n"
                "Copyright ¬© 2025-2026 Honey Badger Universe"
            )

            messagebox.showinfo("TempleCode IDE", about_text)

        about_menu.add_command(label="About TempleCode IDE", command=show_about)

        # Keyboard bindings
        root.bind("<F5>", lambda e: run_code())
        root.bind("<Control-n>", lambda e: new_file())
        root.bind("<Control-o>", lambda e: load_file())
        root.bind("<Control-s>", lambda e: save_file())
        root.bind("<Control-q>", lambda e: exit_app())

        # Edit operation bindings
        root.bind("<Control-z>", lambda e: undo_text())
        root.bind("<Control-y>", lambda e: redo_text())
        root.bind("<Control-Shift-Z>", lambda e: redo_text())
        root.bind("<Control-a>", lambda e: select_all())
        root.bind("<Control-f>", lambda e: find_text())
        root.bind("<Control-h>", lambda e: replace_text())

        # Create GUI layout with PanedWindow for resizable sections
        main_paned = tk.PanedWindow(root, orient=tk.HORIZONTAL, sashwidth=5, bg="#252526")
        main_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Left panel - Editor
        left_panel = tk.Frame(main_paned, bg="#252526")
        main_paned.add(left_panel, width=400)

        editor_frame = tk.LabelFrame(left_panel, text="TempleCode Editor", padx=5, pady=5, bg="#252526", fg="#d4d4d4")
        editor_frame.pack(fill=tk.BOTH, expand=True)

        # Create syntax highlighting text widget
        if PYGMENTS_AVAILABLE:
            editor_text = SyntaxHighlightingText(
                editor_frame,
                language="templecode",
                theme="dark",
                bg="#1e1e1e",
                fg="#d4d4d4",
                insertbackground="#d4d4d4"
            )
        else:
            # Fallback to line-numbered text if pygments not available
            editor_text = LineNumberedText(
                editor_frame,
                bg="#1e1e1e",
                fg="#d4d4d4",
                insertbackground="#d4d4d4"
            )

        editor_text.pack(fill=tk.BOTH, expand=True)

        # Right panel - Split between output and graphics
        right_panel = tk.Frame(main_paned, bg="#252526")
        main_paned.add(right_panel, width=800)

        # Right vertical paned window
        right_paned = tk.PanedWindow(right_panel, orient=tk.VERTICAL, sashwidth=5, bg="#252526")
        right_paned.pack(fill=tk.BOTH, expand=True)

        # Output frame (top of right panel)
        output_frame = tk.LabelFrame(right_paned, text="Output", padx=5, pady=5, bg="#252526", fg="#d4d4d4")
        right_paned.add(output_frame, height=300)

        # Output text widget
        output_text = scrolledtext.ScrolledText(
            output_frame,
            wrap=tk.WORD,
            font=("Courier", 10),
            bg="#1e1e1e",
            fg="#d4d4d4",
            insertbackground="#d4d4d4",
        )
        output_text.pack(fill=tk.BOTH, expand=True)

        # Graphics canvas frame (bottom of right panel)
        graphics_frame = tk.LabelFrame(
            right_paned, text="Turtle Graphics", padx=5, pady=5,
            bg="#252526", fg="#d4d4d4"
        )
        right_paned.add(graphics_frame, height=300)

        # Turtle graphics canvas
        turtle_canvas = tk.Canvas(
            graphics_frame,
            width=600,
            height=400,
            bg="#2d2d2d",
            highlightthickness=1,
            highlightbackground="#3e3e3e",
        )
        turtle_canvas.pack(fill=tk.BOTH, expand=True)

        # Input frame at the bottom
        input_frame = tk.Frame(root, bg="#252526")
        input_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        tk.Label(input_frame, text="Input:", font=("Arial", 10), bg="#252526", fg="#d4d4d4").pack(
            side=tk.LEFT, padx=(0, 5)
        )
        input_entry = tk.Entry(input_frame, font=("Courier", 10), bg="#1e1e1e", fg="#d4d4d4", insertbackground="#d4d4d4")
        input_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))

        input_buffer = []

        def submit_input():
            """Submit input from entry field."""
            value = input_entry.get()
            input_buffer.append(value)
            output_text.insert(tk.END, f">> {value}\n")
            input_entry.delete(0, tk.END)

        input_entry.bind("<Return>", lambda e: submit_input())
        tk.Button(input_frame, text="Submit", command=submit_input, bg="#3e3e3e", fg="#d4d4d4").pack(
            side=tk.LEFT
        )

        # Initialize the interpreter with output widget and canvas
        interpreter = TempleCodeInterpreter(output_text)
        interpreter.ide_turtle_canvas = turtle_canvas
        interpreter.input_buffer = input_buffer  # Wire IDE input bar to interpreter

        # Control buttons frame
        button_frame = tk.Frame(root, bg="#252526")
        button_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        # Create buttons
        tk.Button(
            button_frame,
            text="‚ñ∂ Run",
            command=run_code,
            bg="#4CAF50",
            fg="white",
            font=("Arial", 10, "bold"),
            padx=20,
        ).pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="üìÇ Open", command=load_file, padx=20, bg="#3e3e3e", fg="#d4d4d4").pack(
            side=tk.LEFT, padx=5
        )

        tk.Button(button_frame, text="üíæ Save", command=save_file, padx=20, bg="#3e3e3e", fg="#d4d4d4").pack(
            side=tk.LEFT, padx=5
        )

        tk.Button(
            button_frame, text="üóëÔ∏è Clear Editor", command=clear_editor, padx=15, bg="#3e3e3e", fg="#d4d4d4"
        ).pack(side=tk.LEFT, padx=5)

        tk.Button(
            button_frame, text="üìÑ Clear Output", command=clear_output, padx=15, bg="#3e3e3e", fg="#d4d4d4"
        ).pack(side=tk.LEFT, padx=5)

        tk.Button(
            button_frame, text="üé® Clear Graphics", command=clear_canvas, padx=15, bg="#3e3e3e", fg="#d4d4d4"
        ).pack(side=tk.LEFT, padx=5)

        # Add welcome message
        welcome_msg = """Welcome to TempleCode IDE! üöÄ

TempleCode is a fusion of BASIC, PILOT, and Logo
‚Äî a single retro-inspired language from the early 1990s.

BASIC commands:
  PRINT, LET, IF/THEN, FOR/NEXT, GOTO, GOSUB, DIM, REM

PILOT commands:
  T: (type)  A: (accept)  M: (match)  Y:/N: (conditional)
  J: (jump)  C: (compute) E: (end)    *label

Logo turtle graphics:
  FORWARD, BACK, LEFT, RIGHT, PENUP, PENDOWN
  SETCOLOR, REPEAT [ ... ], TO procname ... END

Enter your code in the left panel and click ‚ñ∂ Run to execute!
"""
        output_text.insert("1.0", welcome_msg)

        # Apply saved theme and font settings
        apply_theme(current_theme)
        apply_font_size(current_font)

        # Start the GUI event loop
        root.mainloop()
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå GUI launch failed: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
